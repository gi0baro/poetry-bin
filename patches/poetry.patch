diff --git a/poetry/console/__init__.py b/poetry/console/__init__.py
index c0c25738..e69de29b 100644
--- a/poetry/console/__init__.py
+++ b/poetry/console/__init__.py
@@ -1,5 +0,0 @@
-from .application import Application
-
-
-def main():
-    return Application().run()
diff --git a/poetry/console/commands/env/info.py b/poetry/console/commands/env/info.py
index 301d88f9..b80ee500 100644
--- a/poetry/console/commands/env/info.py
+++ b/poetry/console/commands/env/info.py
@@ -54,7 +54,7 @@ class EnvInfoCommand(Command):
                 [
                     "<info>Platform</info>: <comment>{}</>".format(env.platform),
                     "<info>OS</info>:       <comment>{}</>".format(env.os),
-                    "<info>Python</info>:   <comment>{}</>".format(env.base),
+                    "<info>Python</info>:   <comment>{}</>".format(env.python),
                 ]
             )
         )
diff --git a/poetry/console/commands/init.py b/poetry/console/commands/init.py
index af72318c..1d616682 100644
--- a/poetry/console/commands/init.py
+++ b/poetry/console/commands/init.py
@@ -66,7 +66,7 @@ The <c1>init</c1> command creates a basic <comment>pyproject.toml</> file in the
         from poetry.core.vcs.git import GitConfig
         from poetry.layouts import layout
         from poetry.utils._compat import Path
-        from poetry.utils.env import SystemEnv
+        from poetry.utils.env import SystemEnv, InterpreterLookup
 
         pyproject = PyProjectTOML(Path.cwd() / "pyproject.toml")
 
@@ -141,7 +141,8 @@ The <c1>init</c1> command creates a basic <comment>pyproject.toml</> file in the
 
         python = self.option("python")
         if not python:
-            current_env = SystemEnv(Path(sys.executable))
+            executable, py_minor, py_patch = InterpreterLookup.find()
+            current_env = SystemEnv(executable)
             default_python = "^{}".format(
                 ".".join(str(v) for v in current_env.version_info[:2])
             )
diff --git a/poetry/console/commands/new.py b/poetry/console/commands/new.py
index 481b0577..e77fad50 100644
--- a/poetry/console/commands/new.py
+++ b/poetry/console/commands/new.py
@@ -24,7 +24,7 @@ class NewCommand(Command):
         from poetry.core.vcs.git import GitConfig
         from poetry.layouts import layout
         from poetry.utils._compat import Path
-        from poetry.utils.env import SystemEnv
+        from poetry.utils.env import SystemEnv, InterpreterLookup
 
         if self.option("src"):
             layout_ = layout("src")
@@ -54,7 +54,8 @@ class NewCommand(Command):
             if author_email:
                 author += " <{}>".format(author_email)
 
-        current_env = SystemEnv(Path(sys.executable))
+        executable, py_minor, py_patch = InterpreterLookup.find()
+        current_env = SystemEnv(executable)
         default_python = "^{}".format(
             ".".join(str(v) for v in current_env.version_info[:2])
         )
diff --git a/poetry/console/commands/self/self.py b/poetry/console/commands/self/self.py
index 3e5cafa9..ff1abefe 100644
--- a/poetry/console/commands/self/self.py
+++ b/poetry/console/commands/self/self.py
@@ -1,5 +1,4 @@
 from ..command import Command
-from .update import SelfUpdateCommand
 
 
 class SelfCommand(Command):
@@ -7,7 +6,7 @@ class SelfCommand(Command):
     name = "self"
     description = "Interact with Poetry directly."
 
-    commands = [SelfUpdateCommand()]
+    commands = []
 
     def handle(self):
         return self.call("help", self._config.name)
diff --git a/poetry/repositories/installed_repository.py b/poetry/repositories/installed_repository.py
index 1320fdd6..03513103 100644
--- a/poetry/repositories/installed_repository.py
+++ b/poetry/repositories/installed_repository.py
@@ -9,10 +9,11 @@ from poetry.utils._compat import Path
 from poetry.utils._compat import metadata
 from poetry.utils.env import Env
 
+from . import __path__
 from .repository import Repository
 
 
-_VENDORS = Path(__file__).parent.parent.joinpath("_vendor")
+_VENDORS = Path(__path__[0]).parent.joinpath("_vendor")
 
 
 try:
diff --git a/poetry/utils/_compat.py b/poetry/utils/_compat.py
index 937f9b30..40e41514 100644
--- a/poetry/utils/_compat.py
+++ b/poetry/utils/_compat.py
@@ -1,5 +1,5 @@
 import sys
-
+import importlib_metadata as metadata
 
 try:
     from functools32 import lru_cache
@@ -13,10 +13,7 @@ except ImportError:
 
 try:
     import zipfile as zipp
-
-    from importlib import metadata
 except ImportError:
-    import importlib_metadata as metadata
     import zipp
 
 try:
diff --git a/poetry/utils/env.py b/poetry/utils/env.py
index 681027ac..abae2724 100644
--- a/poetry/utils/env.py
+++ b/poetry/utils/env.py
@@ -28,6 +28,8 @@ from packaging.tags import interpreter_name
 from packaging.tags import interpreter_version
 from packaging.tags import sys_tags
 
+from poetry import __path__ as __pkgpath__
+from poetry.core.packages import Package
 from poetry.core.semver import parse_constraint
 from poetry.core.semver.version import Version
 from poetry.core.toml.file import TOMLFile
@@ -43,6 +45,12 @@ from poetry.utils._compat import subprocess
 from poetry.utils.helpers import is_dir_writable
 from poetry.utils.helpers import paths_csv
 
+if getattr(sys, "oxidized", False):
+    parents = 1 if sys.platform.startswith("win") else 2
+    __path_assets__ = Path(__pkgpath__[0]).parents[parents] / "assets"
+else:
+    __path_assets__ = None
+
 
 GET_ENVIRONMENT_INFO = """\
 import json
@@ -434,7 +442,7 @@ class EnvManager(object):
         if self._env is not None and not reload:
             return self._env
 
-        python_minor = ".".join([str(v) for v in sys.version_info[:2]])
+        python_minor = InterpreterLookup.find()[1]
 
         venv_path = self._poetry.config.get("virtualenvs.path")
         if venv_path is None:
@@ -470,9 +478,10 @@ class EnvManager(object):
                     return VirtualEnv(venv)
 
             create_venv = self._poetry.config.get("virtualenvs.create", True)
+            pydef_executable, pydef_minor, pydef_patch = InterpreterLookup.find()
 
             if not create_venv:
-                return SystemEnv(Path(sys.prefix))
+                return SystemEnv(pydef_executable)
 
             venv_path = self._poetry.config.get("virtualenvs.path")
             if venv_path is None:
@@ -485,7 +494,7 @@ class EnvManager(object):
             venv = venv_path / name
 
             if not venv.exists():
-                return SystemEnv(Path(sys.prefix))
+                return SystemEnv(pydef_executable)
 
             return VirtualEnv(venv)
 
@@ -647,8 +656,7 @@ class EnvManager(object):
         if not name:
             name = self._poetry.package.name
 
-        python_patch = ".".join([str(v) for v in sys.version_info[:3]])
-        python_minor = ".".join([str(v) for v in sys.version_info[:2]])
+        python_patch, python_minor = None, None
         if executable:
             python_patch = decode(
                 subprocess.check_output(
@@ -665,7 +673,10 @@ class EnvManager(object):
             python_minor = ".".join(python_patch.split(".")[:2])
 
         supported_python = self._poetry.package.python_constraint
-        if not supported_python.allows(Version.parse(python_patch)):
+        if (
+            not python_patch or
+            python_patch and not supported_python.allows(Version.parse(python_patch))
+        ):
             # The currently activated or chosen Python version
             # is not compatible with the Python constraint specified
             # for the project.
@@ -677,60 +688,7 @@ class EnvManager(object):
                     self._poetry.package.python_versions, python_patch
                 )
 
-            io.write_line(
-                "<warning>The currently activated Python version {} "
-                "is not supported by the project ({}).\n"
-                "Trying to find and use a compatible version.</warning> ".format(
-                    python_patch, self._poetry.package.python_versions
-                )
-            )
-
-            for python_to_try in reversed(
-                sorted(
-                    self._poetry.package.AVAILABLE_PYTHONS,
-                    key=lambda v: (v.startswith("3"), -len(v), v),
-                )
-            ):
-                if len(python_to_try) == 1:
-                    if not parse_constraint("^{}.0".format(python_to_try)).allows_any(
-                        supported_python
-                    ):
-                        continue
-                elif not supported_python.allows_all(
-                    parse_constraint(python_to_try + ".*")
-                ):
-                    continue
-
-                python = "python" + python_to_try
-
-                if io.is_debug():
-                    io.write_line("<debug>Trying {}</debug>".format(python))
-
-                try:
-                    python_patch = decode(
-                        subprocess.check_output(
-                            list_to_shell_command(
-                                [
-                                    python,
-                                    "-c",
-                                    "\"import sys; print('.'.join([str(s) for s in sys.version_info[:3]]))\"",
-                                ]
-                            ),
-                            stderr=subprocess.STDOUT,
-                            shell=True,
-                        ).strip()
-                    )
-                except CalledProcessError:
-                    continue
-
-                if not python_patch:
-                    continue
-
-                if supported_python.allows(Version.parse(python_patch)):
-                    io.write_line("Using <c1>{}</c1> ({})".format(python, python_patch))
-                    executable = python
-                    python_minor = ".".join(python_patch.split(".")[:2])
-                    break
+            executable, python_minor, python_patch = InterpreterLookup.find(supported_python)
 
             if not executable:
                 raise NoCompatiblePythonVersionFound(
@@ -753,13 +711,21 @@ class EnvManager(object):
                     "</>"
                 )
 
-                return SystemEnv(Path(sys.prefix))
+                return SystemEnv(executable)
 
             io.write_line(
                 "Creating virtualenv <c1>{}</> in {}".format(name, str(venv_path))
             )
 
             self.build_venv(venv, executable=executable)
+
+            if not root_venv:
+                envs = tomlkit.document()
+                envs_file = TOMLFile(Path(CACHE_DIR) / "virtualenvs" / self.ENVS_FILE)
+                if envs_file.exists():
+                    envs = envs_file.read()
+                envs[name] = {"minor": python_minor, "patch": python_patch}
+                envs_file.write(envs)
         else:
             if force:
                 if not env.is_sane():
@@ -776,22 +742,6 @@ class EnvManager(object):
             elif io.is_very_verbose():
                 io.write_line("Virtualenv <c1>{}</> already exists.".format(name))
 
-        # venv detection:
-        # stdlib venv may symlink sys.executable, so we can't use realpath.
-        # but others can symlink *to* the venv Python,
-        # so we can't just use sys.executable.
-        # So we just check every item in the symlink tree (generally <= 3)
-        p = os.path.normcase(sys.executable)
-        paths = [p]
-        while os.path.islink(p):
-            p = os.path.normcase(os.path.join(os.path.dirname(p), os.readlink(p)))
-            paths.append(p)
-
-        p_venv = os.path.normcase(str(venv))
-        if any(p.startswith(p_venv) for p in paths):
-            # Running properly in the virtualenv, don't need to do anything
-            return SystemEnv(Path(sys.prefix), self.get_base_prefix())
-
         return VirtualEnv(venv)
 
     @classmethod
@@ -805,7 +755,7 @@ class EnvManager(object):
                 "--no-download",
                 "--no-periodic-update",
                 "--python",
-                executable or sys.executable,
+                executable or "python",
                 str(path),
             ]
         )
@@ -1138,96 +1088,56 @@ class SystemEnv(Env):
     A system (i.e. not a virtualenv) Python environment.
     """
 
-    @property
-    def python(self):  # type: () -> str
-        return sys.executable
+    def __init__(self, path, base=None, auto_path=True):
+        self._is_windows = sys.platform == "win32"
+        if auto_path:
+            path = Path(self._run([path, "-"], input_=GET_BASE_PREFIX).strip())
+        super().__init__(path)
 
     @property
-    def sys_path(self):  # type: () -> List[str]
-        return sys.path
-
-    def get_version_info(self):  # type: () -> Tuple[int]
-        return sys.version_info
-
-    def get_python_implementation(self):  # type: () -> str
-        return platform.python_implementation()
-
-    def get_pip_command(self):  # type: () -> List[str]
-        # If we're not in a venv, assume the interpreter we're running on
-        # has a pip and use that
-        return [sys.executable, "-m", "pip"]
-
-    def get_paths(self):  # type: () -> Dict[str, str]
-        # We can't use sysconfig.get_paths() because
-        # on some distributions it does not return the proper paths
-        # (those used by pip for instance). We go through distutils
-        # to get the proper ones.
-        import site
-
-        from distutils.command.install import SCHEME_KEYS  # noqa
-        from distutils.core import Distribution
-
-        d = Distribution()
-        d.parse_config_files()
-        obj = d.get_command_obj("install", create=True)
-        obj.finalize_options()
+    def sys_path(self):
+        output = self.run("python", "-", input_=GET_SYS_PATH)
+        return json.loads(output)
 
-        paths = sysconfig.get_paths().copy()
-        for key in SCHEME_KEYS:
-            if key == "headers":
-                # headers is not a path returned by sysconfig.get_paths()
-                continue
+    def get_version_info(self):
+        output = self.run("python", "-", input_=GET_PYTHON_VERSION)
+        return tuple([int(s) for s in output.strip().split(".")])
 
-            paths[key] = getattr(obj, "install_{}".format(key))
+    def get_python_implementation(self):
+        return self.marker_env["platform_python_implementation"]
 
-        if site.check_enableusersite() and hasattr(obj, "install_usersite"):
-            paths["usersite"] = getattr(obj, "install_usersite")
-            paths["userbase"] = getattr(obj, "install_userbase")
+    def get_marker_env(self):
+        output = self.run("python", "-", input_=GET_ENVIRONMENT_INFO)
+        return json.loads(output)
 
-        return paths
+    def get_paths(self):
+        output = self.run("python", "-", input_=GET_PATHS)
+        return json.loads(output)
 
     def get_supported_tags(self):  # type: () -> List[Tag]
-        return list(sys_tags())
+        if __path_assets__:
+            file_path = __path_assets__ / "packaging_tags.py"
+        else:
+            file_path = Path(packaging.tags.__file__)
 
-    def get_marker_env(self):  # type: () -> Dict[str, Any]
-        if hasattr(sys, "implementation"):
-            info = sys.implementation.version
-            iver = "{0.major}.{0.minor}.{0.micro}".format(info)
-            kind = info.releaselevel
-            if kind != "final":
-                iver += kind[0] + str(info.serial)
+        with file_path.open(encoding="utf-8") as f:
+            script = decode(f.read())
 
-            implementation_name = sys.implementation.name
-        else:
-            iver = "0"
-            implementation_name = ""
+        output = self.run("python", "-", input_=script)
 
-        return {
-            "implementation_name": implementation_name,
-            "implementation_version": iver,
-            "os_name": os.name,
-            "platform_machine": platform.machine(),
-            "platform_release": platform.release(),
-            "platform_system": platform.system(),
-            "platform_version": platform.version(),
-            "python_full_version": platform.python_version(),
-            "platform_python_implementation": platform.python_implementation(),
-            "python_version": ".".join(
-                v for v in platform.python_version().split(".")[:2]
-            ),
-            "sys_platform": sys.platform,
-            "version_info": sys.version_info,
-            # Extra information
-            "interpreter_name": interpreter_name(),
-            "interpreter_version": interpreter_version(),
-        }
+        return [Tag(*t) for t in json.loads(output)]
 
-    def get_pip_version(self):  # type: () -> Version
-        from pip import __version__
+    def get_pip_command(self):
+        return [self.python, "-m", "pip"]
 
-        return Version.parse(__version__)
+    def get_pip_version(self):
+        output = self.run_pip("--version").strip()
+        m = re.match("pip (.+?)(?: from .+)?$", output)
+        if not m:
+            return Version.parse("0.0")
+        return Version.parse(m.group(1))
 
-    def is_venv(self):  # type: () -> bool
+    def is_venv(self):
         return self._path != self._base
 
 
@@ -1266,31 +1176,14 @@ class VirtualEnv(Env):
         return [self._bin("pip")]
 
     def get_supported_tags(self):  # type: () -> List[Tag]
-        file_path = Path(packaging.tags.__file__)
-        if file_path.suffix == ".pyc":
-            # Python 2
-            file_path = file_path.with_suffix(".py")
+        if __path_assets__:
+            file_path = __path_assets__ / "packaging_tags.py"
+        else:
+            file_path = Path(packaging.tags.__file__)
 
         with file_path.open(encoding="utf-8") as f:
             script = decode(f.read())
 
-        script = script.replace(
-            "from ._typing import TYPE_CHECKING, cast",
-            "TYPE_CHECKING = False\ncast = lambda type_, value: value",
-        )
-        script = script.replace(
-            "from ._typing import MYPY_CHECK_RUNNING, cast",
-            "MYPY_CHECK_RUNNING = False\ncast = lambda type_, value: value",
-        )
-
-        script += textwrap.dedent(
-            """
-            import json
-
-            print(json.dumps([(t.interpreter, t.abi, t.platform) for t in sys_tags()]))
-            """
-        )
-
         output = self.run("python", "-", input_=script)
 
         return [Tag(*t) for t in json.loads(output)]
@@ -1366,11 +1259,98 @@ class NullEnv(SystemEnv):
         if path is None:
             path = Path(sys.prefix)
 
-        super(NullEnv, self).__init__(path, base=base)
+        super(NullEnv, self).__init__(path, base=base, auto_path=False)
 
         self._execute = execute
         self.executed = []
 
+    @property
+    def python(self):  # type: () -> str
+        return sys.executable
+
+    @property
+    def sys_path(self):  # type: () -> List[str]
+        return sys.path
+
+    def get_version_info(self):  # type: () -> Tuple[int]
+        return sys.version_info
+
+    def get_python_implementation(self):  # type: () -> str
+        return platform.python_implementation()
+
+    def get_paths(self):  # type: () -> Dict[str, str]
+        # We can't use sysconfig.get_paths() because
+        # on some distributions it does not return the proper paths
+        # (those used by pip for instance). We go through distutils
+        # to get the proper ones.
+        import site
+
+        from distutils.command.install import SCHEME_KEYS  # noqa
+        from distutils.core import Distribution
+
+        d = Distribution()
+        d.parse_config_files()
+        obj = d.get_command_obj("install", create=True)
+        obj.finalize_options()
+
+        paths = sysconfig.get_paths().copy()
+        for key in SCHEME_KEYS:
+            if key == "headers":
+                # headers is not a path returned by sysconfig.get_paths()
+                continue
+
+            paths[key] = getattr(obj, "install_{}".format(key))
+
+        if site.check_enableusersite() and hasattr(obj, "install_usersite"):
+            paths["usersite"] = getattr(obj, "install_usersite")
+            paths["userbase"] = getattr(obj, "install_userbase")
+
+        return paths
+
+    def get_supported_tags(self):  # type: () -> List[Tag]
+        return list(sys_tags())
+
+    def get_marker_env(self):  # type: () -> Dict[str, Any]
+        if hasattr(sys, "implementation"):
+            info = sys.implementation.version
+            iver = "{0.major}.{0.minor}.{0.micro}".format(info)
+            kind = info.releaselevel
+            if kind != "final":
+                iver += kind[0] + str(info.serial)
+
+            implementation_name = sys.implementation.name
+        else:
+            iver = "0"
+            implementation_name = ""
+
+        return {
+            "implementation_name": implementation_name,
+            "implementation_version": iver,
+            "os_name": os.name,
+            "platform_machine": platform.machine(),
+            "platform_release": platform.release(),
+            "platform_system": platform.system(),
+            "platform_version": platform.version(),
+            "python_full_version": platform.python_version(),
+            "platform_python_implementation": platform.python_implementation(),
+            "python_version": ".".join(
+                v for v in platform.python_version().split(".")[:2]
+            ),
+            "sys_platform": sys.platform,
+            "version_info": sys.version_info,
+            # Extra information
+            "interpreter_name": interpreter_name(),
+            "interpreter_version": interpreter_version(),
+        }
+
+    def get_pip_version(self):  # type: () -> Version
+        from pip import __version__
+
+        return Version.parse(__version__)
+
+    def is_venv(self):  # type: () -> bool
+        return self._path != self._base
+
     def get_pip_command(self):  # type: () -> List[str]
         return [self._bin("python"), "-m", "pip"]
 
@@ -1454,3 +1434,69 @@ class MockEnv(NullEnv):
 
     def is_venv(self):  # type: () -> bool
         return self._is_venv
+
+
+class InterpreterLookup:
+    @staticmethod
+    def _version_check(executable, supported_python=None):
+        try:
+            python_patch = decode(
+                subprocess.check_output(
+                    list_to_shell_command(
+                        [
+                            executable,
+                            "-c",
+                            "\"import sys; print('.'.join([str(s) for s in sys.version_info[:3]]))\"",
+                        ]
+                    ),
+                    stderr=subprocess.STDOUT,
+                    shell=True,
+                ).strip()
+            )
+        except CalledProcessError:
+            return False, None, None
+
+        if not python_patch:
+            return False, None, None
+
+        if (
+            not supported_python or
+            (supported_python and supported_python.allows(Version.parse(python_patch)))
+        ):
+            python_minor = ".".join(python_patch.split(".")[:2])
+            return True, python_minor, python_patch
+
+        return False, None, None
+
+    @classmethod
+    def find(cls, constraint=None):
+        executable, minor, patch = None, None, None
+
+        for executable in ["python", "python3", "python2"]:
+            match, minor, patch = cls._version_check(executable, constraint)
+            if match:
+                return executable, minor, patch
+
+        for python_to_try in reversed(
+            sorted(
+                Package.AVAILABLE_PYTHONS,
+                key=lambda v: (v.startswith("3"), -len(v), v),
+            )
+        ):
+            if len(python_to_try) == 1:
+                if not parse_constraint("^{}.0".format(python_to_try)).allows_any(
+                    constraint
+                ):
+                    continue
+            elif not constraint.allows_all(
+                parse_constraint(python_to_try + ".*")
+            ):
+                continue
+
+            python = "python" + python_to_try
+            match, minor, patch = cls._version_check(python, constraint)
+            if match:
+                executable = python
+                break
+
+        return executable, minor, patch
diff --git a/pyproject.toml b/pyproject.toml
index 34f02afe..652fc702 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -24,7 +24,6 @@ classifiers = [
 [tool.poetry.dependencies]
 python = "~2.7 || ^3.5"
 
-poetry-core = "~1.0.3"
 cleo = "^0.8.1"
 clikit = "^0.6.2"
 crashtest = { version = "^0.3.0", python = "^3.6" }
@@ -38,7 +37,6 @@ shellingham = "^1.1"
 tomlkit = ">=0.7.0,<1.0.0"
 pexpect = "^4.7.0"
 packaging = "^20.4"
-virtualenv = { version = "^20.0.26" }
 
 # The typing module is not in the stdlib in Python 2.7
 typing = { version = "^3.6", python = "~2.7" }
diff --git a/tests/conftest.py b/tests/conftest.py
index e2b73936..ac9721ce 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -4,6 +4,7 @@ import shutil
 import sys
 import tempfile
 
+from pathlib import Path
 from typing import Any
 from typing import Dict
 
@@ -56,7 +57,8 @@ class Config(BaseConfig):
 @pytest.fixture
 def config_source():
     source = DictConfigSource()
-    source.add_property("cache-dir", "/foo")
+    # source.add_property("cache-dir", "/foo")
+    source.add_property("cache-dir", str(Path.cwd() / ".pypoetrycache"))
 
     return source
 
diff --git a/tests/console/commands/self/__init__.py b/tests/console/commands/self/__init__.py
deleted file mode 100644
index e69de29b..00000000
diff --git a/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.sha256sum b/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.sha256sum
deleted file mode 100644
index 3229630a..00000000
--- a/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.sha256sum
+++ /dev/null
@@ -1 +0,0 @@
-be3d3b916cb47038899d6ff37e875fd08ba3fed22bcdbf5a92f3f48fd2f15da8
diff --git a/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.tar.gz b/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.tar.gz
deleted file mode 100644
index 09bb17bdeb92ccdc331cba93b1337ec9129f355f..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1041
zcmV+s1n&DEiwFP)U%p-h1MOJdi`zyJ_p|<r#d(pzRU})o!Ehxdy+R?}8TXo(QWiy8
zrJKlFb$5N#l>YCX*_Cv%F2aS{p-ERS`!V0Y+0l+v3#R4q<>Z=A2+w-Go|ti!m@!<$
zcErsvoJ7l2vW}DW66RsFSR|_nNv`QstNWmIDhZh=_AXVLv#KQwMqn$7!QNM}tZn}7
z5Y)$OgoFuR#WvsT=lNeo(Hir=SS5>iu?D^<j*@6X!fQA))cHTpe<8)5P+A=HK{84S
z-`7HFlD<=-JZMJk+8bdzR6G+oqb1i&rls;MV?gO6lZuP#Nn>xTVah~R@b`foTEnl+
zX2VgZ*~j!fQ!Vk0$UZVTLflI6fn|DYWf~^QYN5Cmk~0<5LX@qlEzBF9gXX0QXeRb`
zsylkBe><UTu`g-COV)Bcz{U@-_B<~uQ>Dn(l+woY2t03ZcR&4je@AWr+zty%%2@%M
zyyBWt-!P+qVr4P!R%mEW$P1#6HQSIadV^f}lp;$@a2L_*@#H+y9Z!Q?k34|Ksxry|
z(jH%faZ7(@rb!UeXPeF*dLLMLZb*xak5SA9JdI}nOfwtM`_TbYfBBpfT(>-UELxYX
zFV=CO+R1=wj=~M3OqBl2rsY*FMa`r>8dgjay6>a5UZ9dep;RVYHr_GeCb~xcDV6?=
zeDf_C$;OHH79Zo!bMN}dj95825+}O*!ebEt55PL2`i(8c7W1KU%*Tk|2>pmsQ<R@n
zi9%xvZGuNs_KqtmKJl|T8C|{=)3g`#91kA^GTZdBXXCaxH1%$zQMEmGR^;hWcI2LA
z8wj2-wAkS>CpbN^hJcLQLUyo(gH<_*@YGHZrg>8oC$=n7<JPSFQ$c+)vf=IO*8gz?
zn*Oi7kFL@Ip6UO>WEl<nzvXJ_`oGU{beeuoD6g5R<3H@;@TFLZ-&5#+=<fdh0p1J(
zdMxNvf}G1L-7~*kOO}>M@S)L!JC)Me%%g8_@4mm^^`t%sUin7VoJ^r<s&XNx!1(&-
z-R}18VMM^Zh8h~k)yF^ong)fC`&9eWU>X>$N=yH7Mqryf5)Rk*Q3Y*R#;Zd7vRV8J
zK0zn&f_#_f#2RNg$yp74uquQ8k!S%u3xwyPxS8=vLC4^Sb29L9=6#OjUBE_H|1BK!
z@~?n%^&c))gZfXRFn0BSf%KkL(fc}qQk+IX7$nm#<?x=3&M}-rpsW9V%HeDM^2HAh
zoU8w684v0|UdHbJKbN|T(EGQ($MMGm-rVrp<_6vdl-g4<wIBNCClLOxfqz5YZxH0L
z9~yWovOl=?am$D6^db&AB@O|HfJ49`;1F;KI0PI54grUNL%<>65O4@M1RMhY3W2`?
LE~wAj04M+eXZ{jT

diff --git a/tests/console/commands/self/test_update.py b/tests/console/commands/self/test_update.py
deleted file mode 100644
index 6e094111..00000000
--- a/tests/console/commands/self/test_update.py
+++ /dev/null
@@ -1,91 +0,0 @@
-import os
-
-import pytest
-
-from poetry.__version__ import __version__
-from poetry.core.packages.package import Package
-from poetry.core.semver.version import Version
-from poetry.utils._compat import WINDOWS
-from poetry.utils._compat import Path
-
-
-FIXTURES = Path(__file__).parent.joinpath("fixtures")
-
-
-@pytest.fixture()
-def tester(command_tester_factory):
-    return command_tester_factory("self update")
-
-
-def test_self_update_should_install_all_necessary_elements(
-    tester, http, mocker, environ, tmp_dir
-):
-    os.environ["POETRY_HOME"] = tmp_dir
-
-    command = tester._command
-
-    version = Version.parse(__version__).next_minor.text
-    mocker.patch(
-        "poetry.repositories.pypi_repository.PyPiRepository.find_packages",
-        return_value=[Package("poetry", version)],
-    )
-    mocker.patch.object(command, "_check_recommended_installation", return_value=None)
-    mocker.patch.object(
-        command, "_get_release_name", return_value="poetry-{}-darwin".format(version)
-    )
-    mocker.patch("subprocess.check_output", return_value=b"Python 3.8.2")
-
-    http.register_uri(
-        "GET",
-        command.BASE_URL + "/{}/poetry-{}-darwin.sha256sum".format(version, version),
-        body=FIXTURES.joinpath("poetry-1.0.5-darwin.sha256sum").read_bytes(),
-    )
-    http.register_uri(
-        "GET",
-        command.BASE_URL + "/{}/poetry-{}-darwin.tar.gz".format(version, version),
-        body=FIXTURES.joinpath("poetry-1.0.5-darwin.tar.gz").read_bytes(),
-    )
-
-    tester.execute()
-
-    bin_ = Path(tmp_dir).joinpath("bin")
-    lib = Path(tmp_dir).joinpath("lib")
-    assert bin_.exists()
-
-    script = bin_.joinpath("poetry")
-    assert script.exists()
-
-    expected_script = """\
-# -*- coding: utf-8 -*-
-import glob
-import sys
-import os
-
-lib = os.path.normpath(os.path.join(os.path.realpath(__file__), "../..", "lib"))
-vendors = os.path.join(lib, "poetry", "_vendor")
-current_vendors = os.path.join(
-    vendors, "py{}".format(".".join(str(v) for v in sys.version_info[:2]))
-)
-sys.path.insert(0, lib)
-sys.path.insert(0, current_vendors)
-
-if __name__ == "__main__":
-    from poetry.console import main
-    main()
-"""
-    if not WINDOWS:
-        expected_script = "#!/usr/bin/env python\n" + expected_script
-
-    assert expected_script == script.read_text()
-
-    if WINDOWS:
-        bat = bin_.joinpath("poetry.bat")
-        expected_bat = '@echo off\r\npython "{}" %*\r\n'.format(
-            str(script).replace(os.environ.get("USERPROFILE", ""), "%USERPROFILE%")
-        )
-        assert bat.exists()
-        with bat.open(newline="") as f:
-            assert expected_bat == f.read()
-
-    assert lib.exists()
-    assert lib.joinpath("poetry").exists()
diff --git a/tests/helpers.py b/tests/helpers.py
index f380bb8d..1de03111 100644
--- a/tests/helpers.py
+++ b/tests/helpers.py
@@ -1,7 +1,7 @@
 import os
 import shutil
 
-from poetry.console import Application
+from poetry.console.application import Application
 from poetry.core.masonry.utils.helpers import escape_name
 from poetry.core.masonry.utils.helpers import escape_version
 from poetry.core.packages import Dependency
