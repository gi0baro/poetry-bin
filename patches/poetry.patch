diff --git a/poetry/console/__init__.py b/poetry/console/__init__.py
index c0c25738..e69de29b 100644
--- a/poetry/console/__init__.py
+++ b/poetry/console/__init__.py
@@ -1,5 +0,0 @@
-from .application import Application
-
-
-def main():
-    return Application().run()
diff --git a/poetry/console/commands/env/info.py b/poetry/console/commands/env/info.py
index 301d88f9..b80ee500 100644
--- a/poetry/console/commands/env/info.py
+++ b/poetry/console/commands/env/info.py
@@ -54,7 +54,7 @@ class EnvInfoCommand(Command):
                 [
                     "<info>Platform</info>: <comment>{}</>".format(env.platform),
                     "<info>OS</info>:       <comment>{}</>".format(env.os),
-                    "<info>Python</info>:   <comment>{}</>".format(env.base),
+                    "<info>Python</info>:   <comment>{}</>".format(env.python),
                 ]
             )
         )
diff --git a/poetry/console/commands/init.py b/poetry/console/commands/init.py
index af72318c..1d616682 100644
--- a/poetry/console/commands/init.py
+++ b/poetry/console/commands/init.py
@@ -66,7 +66,7 @@ The <c1>init</c1> command creates a basic <comment>pyproject.toml</> file in the
         from poetry.core.vcs.git import GitConfig
         from poetry.layouts import layout
         from poetry.utils._compat import Path
-        from poetry.utils.env import SystemEnv
+        from poetry.utils.env import SystemEnv, InterpreterLookup
 
         pyproject = PyProjectTOML(Path.cwd() / "pyproject.toml")
 
@@ -141,7 +141,8 @@ The <c1>init</c1> command creates a basic <comment>pyproject.toml</> file in the
 
         python = self.option("python")
         if not python:
-            current_env = SystemEnv(Path(sys.executable))
+            executable, py_minor, py_patch = InterpreterLookup.find()
+            current_env = SystemEnv(executable)
             default_python = "^{}".format(
                 ".".join(str(v) for v in current_env.version_info[:2])
             )
diff --git a/poetry/console/commands/new.py b/poetry/console/commands/new.py
index 481b0577..e77fad50 100644
--- a/poetry/console/commands/new.py
+++ b/poetry/console/commands/new.py
@@ -24,7 +24,7 @@ class NewCommand(Command):
         from poetry.core.vcs.git import GitConfig
         from poetry.layouts import layout
         from poetry.utils._compat import Path
-        from poetry.utils.env import SystemEnv
+        from poetry.utils.env import SystemEnv, InterpreterLookup
 
         if self.option("src"):
             layout_ = layout("src")
@@ -54,7 +54,8 @@ class NewCommand(Command):
             if author_email:
                 author += " <{}>".format(author_email)
 
-        current_env = SystemEnv(Path(sys.executable))
+        executable, py_minor, py_patch = InterpreterLookup.find()
+        current_env = SystemEnv(executable)
         default_python = "^{}".format(
             ".".join(str(v) for v in current_env.version_info[:2])
         )
diff --git a/poetry/console/commands/self/self.py b/poetry/console/commands/self/self.py
index 3e5cafa9..ff1abefe 100644
--- a/poetry/console/commands/self/self.py
+++ b/poetry/console/commands/self/self.py
@@ -1,5 +1,4 @@
 from ..command import Command
-from .update import SelfUpdateCommand
 
 
 class SelfCommand(Command):
@@ -7,7 +6,7 @@ class SelfCommand(Command):
     name = "self"
     description = "Interact with Poetry directly."
 
-    commands = [SelfUpdateCommand()]
+    commands = []
 
     def handle(self):
         return self.call("help", self._config.name)
diff --git a/poetry/repositories/installed_repository.py b/poetry/repositories/installed_repository.py
index 1320fdd6..03513103 100644
--- a/poetry/repositories/installed_repository.py
+++ b/poetry/repositories/installed_repository.py
@@ -9,10 +9,11 @@ from poetry.utils._compat import Path
 from poetry.utils._compat import metadata
 from poetry.utils.env import Env
 
+from . import __path__
 from .repository import Repository
 
 
-_VENDORS = Path(__file__).parent.parent.joinpath("_vendor")
+_VENDORS = Path(__path__[0]).parent.joinpath("_vendor")
 
 
 try:
diff --git a/poetry/utils/_compat.py b/poetry/utils/_compat.py
index 937f9b30..40e41514 100644
--- a/poetry/utils/_compat.py
+++ b/poetry/utils/_compat.py
@@ -1,5 +1,5 @@
 import sys
-
+import importlib_metadata as metadata
 
 try:
     from functools32 import lru_cache
@@ -13,10 +13,7 @@ except ImportError:
 
 try:
     import zipfile as zipp
-
-    from importlib import metadata
 except ImportError:
-    import importlib_metadata as metadata
     import zipp
 
 try:
diff --git a/poetry/utils/env.py b/poetry/utils/env.py
index 681027ac..1da3c8d1 100644
--- a/poetry/utils/env.py
+++ b/poetry/utils/env.py
@@ -28,6 +28,7 @@ from packaging.tags import interpreter_name
 from packaging.tags import interpreter_version
 from packaging.tags import sys_tags
 
+from poetry import __path__ as __pkgpath__
 from poetry.core.semver import parse_constraint
 from poetry.core.semver.version import Version
 from poetry.core.toml.file import TOMLFile
@@ -434,7 +435,7 @@ class EnvManager(object):
         if self._env is not None and not reload:
             return self._env
 
-        python_minor = ".".join([str(v) for v in sys.version_info[:2]])
+        python_minor = InterpreterLookup.find()[1]
 
         venv_path = self._poetry.config.get("virtualenvs.path")
         if venv_path is None:
@@ -470,9 +471,10 @@ class EnvManager(object):
                     return VirtualEnv(venv)
 
             create_venv = self._poetry.config.get("virtualenvs.create", True)
+            pydef_executable, pydef_minor, pydef_patch = InterpreterLookup.find()
 
             if not create_venv:
-                return SystemEnv(Path(sys.prefix))
+                return SystemEnv(pydef_executable)
 
             venv_path = self._poetry.config.get("virtualenvs.path")
             if venv_path is None:
@@ -485,7 +487,7 @@ class EnvManager(object):
             venv = venv_path / name
 
             if not venv.exists():
-                return SystemEnv(Path(sys.prefix))
+                return SystemEnv(pydef_executable)
 
             return VirtualEnv(venv)
 
@@ -647,8 +649,7 @@ class EnvManager(object):
         if not name:
             name = self._poetry.package.name
 
-        python_patch = ".".join([str(v) for v in sys.version_info[:3]])
-        python_minor = ".".join([str(v) for v in sys.version_info[:2]])
+        python_patch, python_minor = None, None
         if executable:
             python_patch = decode(
                 subprocess.check_output(
@@ -665,7 +666,10 @@ class EnvManager(object):
             python_minor = ".".join(python_patch.split(".")[:2])
 
         supported_python = self._poetry.package.python_constraint
-        if not supported_python.allows(Version.parse(python_patch)):
+        if (
+            not python_patch or
+            python_patch and not supported_python.allows(Version.parse(python_patch))
+        ):
             # The currently activated or chosen Python version
             # is not compatible with the Python constraint specified
             # for the project.
@@ -677,60 +681,7 @@ class EnvManager(object):
                     self._poetry.package.python_versions, python_patch
                 )
 
-            io.write_line(
-                "<warning>The currently activated Python version {} "
-                "is not supported by the project ({}).\n"
-                "Trying to find and use a compatible version.</warning> ".format(
-                    python_patch, self._poetry.package.python_versions
-                )
-            )
-
-            for python_to_try in reversed(
-                sorted(
-                    self._poetry.package.AVAILABLE_PYTHONS,
-                    key=lambda v: (v.startswith("3"), -len(v), v),
-                )
-            ):
-                if len(python_to_try) == 1:
-                    if not parse_constraint("^{}.0".format(python_to_try)).allows_any(
-                        supported_python
-                    ):
-                        continue
-                elif not supported_python.allows_all(
-                    parse_constraint(python_to_try + ".*")
-                ):
-                    continue
-
-                python = "python" + python_to_try
-
-                if io.is_debug():
-                    io.write_line("<debug>Trying {}</debug>".format(python))
-
-                try:
-                    python_patch = decode(
-                        subprocess.check_output(
-                            list_to_shell_command(
-                                [
-                                    python,
-                                    "-c",
-                                    "\"import sys; print('.'.join([str(s) for s in sys.version_info[:3]]))\"",
-                                ]
-                            ),
-                            stderr=subprocess.STDOUT,
-                            shell=True,
-                        ).strip()
-                    )
-                except CalledProcessError:
-                    continue
-
-                if not python_patch:
-                    continue
-
-                if supported_python.allows(Version.parse(python_patch)):
-                    io.write_line("Using <c1>{}</c1> ({})".format(python, python_patch))
-                    executable = python
-                    python_minor = ".".join(python_patch.split(".")[:2])
-                    break
+            executable, python_minor, python_patch = InterpreterLookup.find(supported_python)
 
             if not executable:
                 raise NoCompatiblePythonVersionFound(
@@ -753,13 +704,21 @@ class EnvManager(object):
                     "</>"
                 )
 
-                return SystemEnv(Path(sys.prefix))
+                return SystemEnv(executable)
 
             io.write_line(
                 "Creating virtualenv <c1>{}</> in {}".format(name, str(venv_path))
             )
 
             self.build_venv(venv, executable=executable)
+
+            if not root_venv:
+                envs = tomlkit.document()
+                envs_file = TOMLFile(Path(CACHE_DIR) / "virtualenvs" / self.ENVS_FILE)
+                if envs_file.exists():
+                    envs = envs_file.read()
+                envs[name] = {"minor": python_minor, "patch": python_patch}
+                envs_file.write(envs)
         else:
             if force:
                 if not env.is_sane():
@@ -776,22 +735,6 @@ class EnvManager(object):
             elif io.is_very_verbose():
                 io.write_line("Virtualenv <c1>{}</> already exists.".format(name))
 
-        # venv detection:
-        # stdlib venv may symlink sys.executable, so we can't use realpath.
-        # but others can symlink *to* the venv Python,
-        # so we can't just use sys.executable.
-        # So we just check every item in the symlink tree (generally <= 3)
-        p = os.path.normcase(sys.executable)
-        paths = [p]
-        while os.path.islink(p):
-            p = os.path.normcase(os.path.join(os.path.dirname(p), os.readlink(p)))
-            paths.append(p)
-
-        p_venv = os.path.normcase(str(venv))
-        if any(p.startswith(p_venv) for p in paths):
-            # Running properly in the virtualenv, don't need to do anything
-            return SystemEnv(Path(sys.prefix), self.get_base_prefix())
-
         return VirtualEnv(venv)
 
     @classmethod
@@ -805,7 +748,7 @@ class EnvManager(object):
                 "--no-download",
                 "--no-periodic-update",
                 "--python",
-                executable or sys.executable,
+                executable or "python",
                 str(path),
             ]
         )
@@ -1138,96 +1081,52 @@ class SystemEnv(Env):
     A system (i.e. not a virtualenv) Python environment.
     """
 
-    @property
-    def python(self):  # type: () -> str
-        return sys.executable
+    def __init__(self, path, base=None):
+        self._is_windows = sys.platform == "win32"
+        path = Path(self._run([path, "-"], input_=GET_BASE_PREFIX).strip())
+        super().__init__(path)
 
     @property
-    def sys_path(self):  # type: () -> List[str]
-        return sys.path
-
-    def get_version_info(self):  # type: () -> Tuple[int]
-        return sys.version_info
+    def sys_path(self):
+        output = self.run("python", "-", input_=GET_SYS_PATH)
+        return json.loads(output)
 
-    def get_python_implementation(self):  # type: () -> str
-        return platform.python_implementation()
+    def get_version_info(self):
+        output = self.run("python", "-", input_=GET_PYTHON_VERSION)
+        return tuple([int(s) for s in output.strip().split(".")])
 
-    def get_pip_command(self):  # type: () -> List[str]
-        # If we're not in a venv, assume the interpreter we're running on
-        # has a pip and use that
-        return [sys.executable, "-m", "pip"]
+    def get_python_implementation(self):
+        return self.marker_env["platform_python_implementation"]
 
-    def get_paths(self):  # type: () -> Dict[str, str]
-        # We can't use sysconfig.get_paths() because
-        # on some distributions it does not return the proper paths
-        # (those used by pip for instance). We go through distutils
-        # to get the proper ones.
-        import site
-
-        from distutils.command.install import SCHEME_KEYS  # noqa
-        from distutils.core import Distribution
-
-        d = Distribution()
-        d.parse_config_files()
-        obj = d.get_command_obj("install", create=True)
-        obj.finalize_options()
-
-        paths = sysconfig.get_paths().copy()
-        for key in SCHEME_KEYS:
-            if key == "headers":
-                # headers is not a path returned by sysconfig.get_paths()
-                continue
+    def get_marker_env(self):
+        output = self.run("python", "-", input_=GET_ENVIRONMENT_INFO)
+        return json.loads(output)
 
-            paths[key] = getattr(obj, "install_{}".format(key))
+    def get_paths(self):
+        output = self.run("python", "-", input_=GET_PATHS)
+        return json.loads(output)
 
-        if site.check_enableusersite() and hasattr(obj, "install_usersite"):
-            paths["usersite"] = getattr(obj, "install_usersite")
-            paths["userbase"] = getattr(obj, "install_userbase")
+    def get_supported_tags(self):  # type: () -> List[Tag]
+        file_path = Path(__pkgpath__[0]).parents[2] / "assets" / "packaging_tags.py"
 
-        return paths
+        with file_path.open(encoding="utf-8") as f:
+            script = decode(f.read())
 
-    def get_supported_tags(self):  # type: () -> List[Tag]
-        return list(sys_tags())
+        output = self.run("python", "-", input_=script)
 
-    def get_marker_env(self):  # type: () -> Dict[str, Any]
-        if hasattr(sys, "implementation"):
-            info = sys.implementation.version
-            iver = "{0.major}.{0.minor}.{0.micro}".format(info)
-            kind = info.releaselevel
-            if kind != "final":
-                iver += kind[0] + str(info.serial)
-
-            implementation_name = sys.implementation.name
-        else:
-            iver = "0"
-            implementation_name = ""
-
-        return {
-            "implementation_name": implementation_name,
-            "implementation_version": iver,
-            "os_name": os.name,
-            "platform_machine": platform.machine(),
-            "platform_release": platform.release(),
-            "platform_system": platform.system(),
-            "platform_version": platform.version(),
-            "python_full_version": platform.python_version(),
-            "platform_python_implementation": platform.python_implementation(),
-            "python_version": ".".join(
-                v for v in platform.python_version().split(".")[:2]
-            ),
-            "sys_platform": sys.platform,
-            "version_info": sys.version_info,
-            # Extra information
-            "interpreter_name": interpreter_name(),
-            "interpreter_version": interpreter_version(),
-        }
+        return [Tag(*t) for t in json.loads(output)]
 
-    def get_pip_version(self):  # type: () -> Version
-        from pip import __version__
+    def get_pip_command(self):
+        return [self.python, "-m", "pip"]
 
-        return Version.parse(__version__)
+    def get_pip_version(self):
+        output = self.run_pip("--version").strip()
+        m = re.match("pip (.+?)(?: from .+)?$", output)
+        if not m:
+            return Version.parse("0.0")
+        return Version.parse(m.group(1))
 
-    def is_venv(self):  # type: () -> bool
+    def is_venv(self):
         return self._path != self._base
 
 
@@ -1266,31 +1165,11 @@ class VirtualEnv(Env):
         return [self._bin("pip")]
 
     def get_supported_tags(self):  # type: () -> List[Tag]
-        file_path = Path(packaging.tags.__file__)
-        if file_path.suffix == ".pyc":
-            # Python 2
-            file_path = file_path.with_suffix(".py")
+        file_path = Path(__pkgpath__[0]).parents[2] / "assets" / "packaging_tags.py"
 
         with file_path.open(encoding="utf-8") as f:
             script = decode(f.read())
 
-        script = script.replace(
-            "from ._typing import TYPE_CHECKING, cast",
-            "TYPE_CHECKING = False\ncast = lambda type_, value: value",
-        )
-        script = script.replace(
-            "from ._typing import MYPY_CHECK_RUNNING, cast",
-            "MYPY_CHECK_RUNNING = False\ncast = lambda type_, value: value",
-        )
-
-        script += textwrap.dedent(
-            """
-            import json
-
-            print(json.dumps([(t.interpreter, t.abi, t.platform) for t in sys_tags()]))
-            """
-        )
-
         output = self.run("python", "-", input_=script)
 
         return [Tag(*t) for t in json.loads(output)]
@@ -1454,3 +1333,69 @@ class MockEnv(NullEnv):
 
     def is_venv(self):  # type: () -> bool
         return self._is_venv
+
+
+class InterpreterLookup:
+    @staticmethod
+    def _version_check(executable, supported_python=None):
+        try:
+            python_patch = decode(
+                subprocess.check_output(
+                    list_to_shell_command(
+                        [
+                            executable,
+                            "-c",
+                            "\"import sys; print('.'.join([str(s) for s in sys.version_info[:3]]))\"",
+                        ]
+                    ),
+                    stderr=subprocess.STDOUT,
+                    shell=True,
+                ).strip()
+            )
+        except CalledProcessError:
+            return False, None, None
+
+        if not python_patch:
+            return False, None, None
+
+        if (
+            not supported_python or
+            (supported_python and supported_python.allows(Version.parse(python_patch)))
+        ):
+            python_minor = ".".join(python_patch.split(".")[:2])
+            return True, python_minor, python_patch
+
+        return False, None, None
+
+    @classmethod
+    def find(cls, constraint=None):
+        executable, minor, patch = None, None, None
+
+        for executable in ["python", "python3", "python2"]:
+            match, minor, patch = cls._version_check(executable, constraint)
+            if match:
+                return executable, minor, patch
+
+        for python_to_try in reversed(
+            sorted(
+                self._poetry.package.AVAILABLE_PYTHONS,
+                key=lambda v: (v.startswith("3"), -len(v), v),
+            )
+        ):
+            if len(python_to_try) == 1:
+                if not parse_constraint("^{}.0".format(python_to_try)).allows_any(
+                    constraint
+                ):
+                    continue
+            elif not constraint.allows_all(
+                parse_constraint(python_to_try + ".*")
+            ):
+                continue
+
+            python = "python" + python_to_try
+            match, minor, patch = cls._version_check(python, constraint)
+            if match:
+                executable = python
+                break
+
+        return executable, minor, patch
diff --git a/pyproject.toml b/pyproject.toml
index 34f02afe..652fc702 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -24,7 +24,6 @@ classifiers = [
 [tool.poetry.dependencies]
 python = "~2.7 || ^3.5"
 
-poetry-core = "~1.0.3"
 cleo = "^0.8.1"
 clikit = "^0.6.2"
 crashtest = { version = "^0.3.0", python = "^3.6" }
@@ -38,7 +37,6 @@ shellingham = "^1.1"
 tomlkit = ">=0.7.0,<1.0.0"
 pexpect = "^4.7.0"
 packaging = "^20.4"
-virtualenv = { version = "^20.0.26" }
 
 # The typing module is not in the stdlib in Python 2.7
 typing = { version = "^3.6", python = "~2.7" }
