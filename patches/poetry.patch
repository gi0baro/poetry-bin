diff --git a/pyproject.toml b/pyproject.toml
index 626531b1..caa6d6b0 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -54,7 +54,7 @@ html5lib = "^1.0"
 importlib-metadata = { version = "^4.4", python = "<3.10" }
 jsonschema = "^4.10.0"
 # keyring uses calver, so version is unclamped
-keyring = ">=21.2.0"
+keyring = "~22.3.0"
 # packaging uses calver, so version is unclamped
 packaging = ">=20.4"
 pexpect = "^4.7.0"
diff --git a/src/poetry/console/application.py b/src/poetry/console/application.py
index 2b6bd633..bf64986e 100644
--- a/src/poetry/console/application.py
+++ b/src/poetry/console/application.py
@@ -83,7 +83,7 @@ COMMANDS = [
     "self install",
     "self lock",
     "self remove",
-    "self update",
+    # "self update",
     "self show",
     "self show plugins",
     # Source commands
diff --git a/src/poetry/console/commands/init.py b/src/poetry/console/commands/init.py
index e2ebf9cf..ef4c98f1 100644
--- a/src/poetry/console/commands/init.py
+++ b/src/poetry/console/commands/init.py
@@ -75,7 +75,7 @@ The <c1>init</c1> command creates a basic <comment>pyproject.toml</> file in the
         from poetry.core.vcs.git import GitConfig
 
         from poetry.layouts import layout
-        from poetry.utils.env import SystemEnv
+        from poetry.utils.env import SystemEnv, InterpreterLookup
 
         pyproject = PyProjectTOML(Path.cwd() / "pyproject.toml")
 
@@ -147,7 +147,8 @@ The <c1>init</c1> command creates a basic <comment>pyproject.toml</> file in the
 
         python = self.option("python")
         if not python:
-            current_env = SystemEnv(Path(sys.executable))
+            executable, _, _ = InterpreterLookup.find()
+            current_env = SystemEnv(Path(executable))
             default_python = "^" + ".".join(
                 str(v) for v in current_env.version_info[:2]
             )
diff --git a/src/poetry/console/commands/new.py b/src/poetry/console/commands/new.py
index cde571aa..0a25b2a0 100644
--- a/src/poetry/console/commands/new.py
+++ b/src/poetry/console/commands/new.py
@@ -32,7 +32,7 @@ class NewCommand(Command):
         from poetry.core.vcs.git import GitConfig
 
         from poetry.layouts import layout
-        from poetry.utils.env import SystemEnv
+        from poetry.utils.env import SystemEnv, InterpreterLookup
 
         if self.option("src"):
             layout_cls = layout("src")
@@ -65,7 +65,8 @@ class NewCommand(Command):
             if author_email:
                 author += f" <{author_email}>"
 
-        current_env = SystemEnv(Path(sys.executable))
+        executable, _, _ = InterpreterLookup.find()
+        current_env = SystemEnv(Path(executable))
         default_python = "^" + ".".join(str(v) for v in current_env.version_info[:2])
 
         layout_ = layout_cls(
diff --git a/src/poetry/json/__init__.py b/src/poetry/json/__init__.py
index 1e237794..a5849e00 100644
--- a/src/poetry/json/__init__.py
+++ b/src/poetry/json/__init__.py
@@ -1,26 +1,19 @@
 from __future__ import annotations
 
 import json
-import os
 
-from pathlib import Path
+from importlib import resources
 from typing import Any
 
 import jsonschema
 
-from poetry.core.json import SCHEMA_DIR as CORE_SCHEMA_DIR
-
-
-SCHEMA_DIR = os.path.join(os.path.dirname(__file__), "schemas")
-
 
 class ValidationError(ValueError):
     pass
 
 
 def validate_object(obj: dict[str, Any]) -> list[str]:
-    schema_file = Path(SCHEMA_DIR, "poetry.json")
-    schema = json.loads(schema_file.read_text(encoding="utf-8"))
+    schema = json.loads(resources.read_text(f"{__name__}.schemas", "poetry.json"))
 
     validator = jsonschema.Draft7Validator(schema)
     validation_errors = sorted(
@@ -39,7 +32,7 @@ def validate_object(obj: dict[str, Any]) -> list[str]:
         errors.append(message)
 
     core_schema = json.loads(
-        Path(CORE_SCHEMA_DIR, "poetry-schema.json").read_text(encoding="utf-8")
+        resources.read_text(f"poetry.core.json.schemas", "poetry-schema.json")
     )
 
     if core_schema["additionalProperties"]:
diff --git a/src/poetry/repositories/installed_repository.py b/src/poetry/repositories/installed_repository.py
index 228df353..087d01de 100644
--- a/src/poetry/repositories/installed_repository.py
+++ b/src/poetry/repositories/installed_repository.py
@@ -20,9 +20,6 @@ if TYPE_CHECKING:
     from poetry.utils.env import Env
 
 
-_VENDORS = Path(__file__).parent.parent.joinpath("_vendor")
-
-
 try:
     FileNotFoundError
 except NameError:
@@ -281,13 +278,6 @@ class InstalledRepository(Repository):
                 if name in seen:
                     continue
 
-                try:
-                    path.relative_to(_VENDORS)
-                except ValueError:
-                    pass
-                else:
-                    continue
-
                 package = cls.create_package_from_distribution(distribution, env)
 
                 if with_dependencies:
diff --git a/src/poetry/utils/_compat.py b/src/poetry/utils/_compat.py
index a1c81582..b06ce4fb 100644
--- a/src/poetry/utils/_compat.py
+++ b/src/poetry/utils/_compat.py
@@ -4,14 +4,7 @@ import sys
 
 from contextlib import suppress
 
-
-# TODO: use try/except ImportError when
-# https://github.com/python/mypy/issues/1393 is fixed
-if sys.version_info < (3, 10):
-    # compatibility for python <3.10
-    import importlib_metadata as metadata
-else:
-    from importlib import metadata
+import importlib_metadata as metadata
 
 WINDOWS = sys.platform == "win32"
 
diff --git a/src/poetry/utils/env.py b/src/poetry/utils/env.py
index ab645bd7..eb84d960 100644
--- a/src/poetry/utils/env.py
+++ b/src/poetry/utils/env.py
@@ -30,6 +30,7 @@ from packaging.tags import Tag
 from packaging.tags import interpreter_name
 from packaging.tags import interpreter_version
 from packaging.tags import sys_tags
+from poetry.core.packages.package import Package
 from poetry.core.semver.helpers import parse_constraint
 from poetry.core.semver.version import Version
 from poetry.core.toml.file import TOMLFile
@@ -660,7 +661,10 @@ class EnvManager:
         if self._env is not None and not reload:
             return self._env
 
-        python_minor = ".".join([str(v) for v in sys.version_info[:2]])
+        python_minor = (
+            InterpreterLookup.find()[1] or
+            ".".join(str(c) for c in sys.version_info[:2])
+        )
 
         venv_path = self._poetry.config.virtualenvs_path
 
@@ -861,8 +865,7 @@ class EnvManager:
             name = self._poetry.package.name
         assert name is not None
 
-        python_patch = ".".join([str(v) for v in sys.version_info[:3]])
-        python_minor = ".".join([str(v) for v in sys.version_info[:2]])
+        python_patch, python_minor = None, None
         if executable:
             python_patch = decode(
                 subprocess.check_output(
@@ -875,7 +878,10 @@ class EnvManager:
             python_minor = ".".join(python_patch.split(".")[:2])
 
         supported_python = self._poetry.package.python_constraint
-        if not supported_python.allows(Version.parse(python_patch)):
+        if (
+            not python_patch or
+            python_patch and not supported_python.allows(Version.parse(python_patch))
+        ):
             # The currently activated or chosen Python version
             # is not compatible with the Python constraint specified
             # for the project.
@@ -887,53 +893,7 @@ class EnvManager:
                     self._poetry.package.python_versions, python_patch
                 )
 
-            io.write_error_line(
-                f"<warning>The currently activated Python version {python_patch} is not"
-                f" supported by the project ({self._poetry.package.python_versions}).\n"
-                "Trying to find and use a compatible version.</warning> "
-            )
-
-            for python_to_try in sorted(
-                self._poetry.package.AVAILABLE_PYTHONS,
-                key=lambda v: (v.startswith("3"), -len(v), v),
-                reverse=True,
-            ):
-                if len(python_to_try) == 1:
-                    if not parse_constraint(f"^{python_to_try}.0").allows_any(
-                        supported_python
-                    ):
-                        continue
-                elif not supported_python.allows_any(
-                    parse_constraint(python_to_try + ".*")
-                ):
-                    continue
-
-                python = "python" + python_to_try
-
-                if io.is_debug():
-                    io.write_line(f"<debug>Trying {python}</debug>")
-
-                try:
-                    python_patch = decode(
-                        subprocess.check_output(
-                            list_to_shell_command(
-                                [python, "-c", GET_PYTHON_VERSION_ONELINER]
-                            ),
-                            stderr=subprocess.STDOUT,
-                            shell=True,
-                        ).strip()
-                    )
-                except CalledProcessError:
-                    continue
-
-                if not python_patch:
-                    continue
-
-                if supported_python.allows(Version.parse(python_patch)):
-                    io.write_line(f"Using <c1>{python}</c1> ({python_patch})")
-                    executable = python
-                    python_minor = ".".join(python_patch.split(".")[:2])
-                    break
+            executable, python_minor, python_patch = InterpreterLookup.find(supported_python)
 
             if not executable:
                 raise NoCompatiblePythonVersionFound(
@@ -990,22 +950,6 @@ class EnvManager:
                 prompt=venv_prompt,
             )
 
-        # venv detection:
-        # stdlib venv may symlink sys.executable, so we can't use realpath.
-        # but others can symlink *to* the venv Python,
-        # so we can't just use sys.executable.
-        # So we just check every item in the symlink tree (generally <= 3)
-        p = os.path.normcase(sys.executable)
-        paths = [p]
-        while os.path.islink(p):
-            p = os.path.normcase(os.path.join(os.path.dirname(p), os.readlink(p)))
-            paths.append(p)
-
-        p_venv = os.path.normcase(str(venv))
-        if any(p.startswith(p_venv) for p in paths):
-            # Running properly in the virtualenv, don't need to do anything
-            return self.get_system_env()
-
         return VirtualEnv(venv)
 
     @classmethod
@@ -1050,7 +994,7 @@ class EnvManager:
             "--no-download",
             "--no-periodic-update",
             "--python",
-            executable or sys.executable,
+            executable or "python",
         ]
 
         if prompt is not None:
@@ -1114,9 +1058,13 @@ class EnvManager:
         want to retrieve Poetry's custom virtual environment
         (e.g. plugin installation or self update).
         """
-        prefix, base_prefix = Path(sys.prefix), Path(cls.get_base_prefix())
-        env: Env = SystemEnv(prefix)
-        if not naive:
+        pydef_executable, _, _ = InterpreterLookup.find()
+        prefix, base_prefix = (
+            Path(pydef_executable) if pydef_executable else None,
+            Path(cls.get_base_prefix())
+        )
+        env: Env = SystemEnv(prefix) if prefix else NullEnv()
+        if not naive and prefix:
             if prefix.joinpath("poetry_env").exists():
                 env = GenericEnv(base_prefix, child_env=env)
             else:
@@ -1542,97 +1490,53 @@ class SystemEnv(Env):
     A system (i.e. not a virtualenv) Python environment.
     """
 
-    @property
-    def python(self) -> str:
-        return sys.executable
+    def __init__(self, path: Path, base: Path | None = None, auto_path: bool = True) -> None:
+        self._is_windows = sys.platform == "win32"
+        if auto_path and path:
+            path = Path(
+                self._run(
+                    [str(path), "-W", "ignore", "-"],
+                    input_=GET_BASE_PREFIX
+                ).strip()
+            )
+        super().__init__(path, base=base)
 
     @property
     def sys_path(self) -> list[str]:
-        return sys.path
+        output = self.run_python_script(GET_SYS_PATH)
+        return json.loads(output)
 
     def get_version_info(self) -> tuple[Any, ...]:
-        return tuple(sys.version_info)
+        output = self.run_python_script(GET_PYTHON_VERSION)
+        return tuple([int(s) for s in output.strip().split(".")])
 
     def get_python_implementation(self) -> str:
-        return platform.python_implementation()
+        return self.marker_env["platform_python_implementation"]
 
-    def get_pip_command(self, embedded: bool = False) -> list[str]:
-        # If we're not in a venv, assume the interpreter we're running on
-        # has a pip and use that
-        return [sys.executable, self.pip_embedded if embedded else self.pip]
+    def get_marker_env(self) -> dict[str, Any]:
+        output = self.run_python_script(GET_ENVIRONMENT_INFO)
+        return json.loads(output)
 
     def get_paths(self) -> dict[str, str]:
-        # We can't use sysconfig.get_paths() because
-        # on some distributions it does not return the proper paths
-        # (those used by pip for instance). We go through distutils
-        # to get the proper ones.
-        import site
-
-        from distutils.command.install import SCHEME_KEYS
-        from distutils.core import Distribution
-
-        d = Distribution()
-        d.parse_config_files()
-        with warnings.catch_warnings():
-            warnings.filterwarnings("ignore", "setup.py install is deprecated")
-            obj = d.get_command_obj("install", create=True)
-        assert obj is not None
-        obj.finalize_options()
-
-        paths = sysconfig.get_paths().copy()
-        for key in SCHEME_KEYS:
-            if key == "headers":
-                # headers is not a path returned by sysconfig.get_paths()
-                continue
-
-            paths[key] = getattr(obj, f"install_{key}")
-
-        if site.check_enableusersite():
-            usersite = getattr(obj, "install_usersite", None)
-            userbase = getattr(obj, "install_userbase", None)
-            if usersite is not None and userbase is not None:
-                paths["usersite"] = usersite
-                paths["userbase"] = userbase
-
-        return paths
+        output = self.run_python_script(GET_PATHS)
+        return json.loads(output)
 
     def get_supported_tags(self) -> list[Tag]:
-        return list(sys_tags())
-
-    def get_marker_env(self) -> dict[str, Any]:
-        if hasattr(sys, "implementation"):
-            info = sys.implementation.version
-            iver = f"{info.major}.{info.minor}.{info.micro}"
-            kind = info.releaselevel
-            if kind != "final":
-                iver += kind[0] + str(info.serial)
-
-            implementation_name = sys.implementation.name
-        else:
-            iver = "0"
-            implementation_name = ""
-
-        return {
-            "implementation_name": implementation_name,
-            "implementation_version": iver,
-            "os_name": os.name,
-            "platform_machine": platform.machine(),
-            "platform_release": platform.release(),
-            "platform_system": platform.system(),
-            "platform_version": platform.version(),
-            "python_full_version": platform.python_version(),
-            "platform_python_implementation": platform.python_implementation(),
-            "python_version": ".".join(platform.python_version().split(".")[:2]),
-            "sys_platform": sys.platform,
-            "version_info": sys.version_info,
-            "interpreter_name": interpreter_name(),
-            "interpreter_version": interpreter_version(),
-        }
+        output = self.run_python_script(GET_SYS_TAGS)
+        return [Tag(*t) for t in json.loads(output)]
 
-    def get_pip_version(self) -> Version:
-        from pip import __version__
+    def get_pip_command(self, embedded: bool = False) -> list[str]:
+        return [
+            self._bin(self._executable),
+            self.pip_embedded if embedded else self.pip,
+        ]
 
-        return Version.parse(__version__)
+    def get_pip_version(self):
+        output = self.run_pip("--version").strip()
+        m = re.match("pip (.+?)(?: from .+)?$", output)
+        if not m:
+            return Version.parse("0.0")
+        return Version.parse(m.group(1))
 
     def is_venv(self) -> bool:
         return self._path != self._base
@@ -1853,16 +1757,100 @@ class NullEnv(SystemEnv):
         if path is None:
             path = Path(sys.prefix)
 
-        super().__init__(path, base=base)
+        super().__init__(path, base=base, auto_path=False)
 
         self._execute = execute
         self.executed: list[list[str]] = []
 
+    @property
+    def python(self) -> str:
+        return sys.executable
+
+    @property
+    def sys_path(self) -> list[str]:
+        return sys.path
+
+    def get_version_info(self) -> tuple[Any, ...]:
+        return tuple(sys.version_info)
+
+    def get_python_implementation(self) -> str:
+        return platform.python_implementation()
+
     def get_pip_command(self, embedded: bool = False) -> list[str]:
-        return [
-            self._bin(self._executable),
-            self.pip_embedded if embedded else self.pip,
-        ]
+        return [sys.executable, self.pip_embedded if embedded else self.pip]
+
+    def get_paths(self) -> dict[str, str]:
+        # We can't use sysconfig.get_paths() because
+        # on some distributions it does not return the proper paths
+        # (those used by pip for instance). We go through distutils
+        # to get the proper ones.
+        import site
+
+        from distutils.command.install import SCHEME_KEYS
+        from distutils.core import Distribution
+
+        d = Distribution()
+        d.parse_config_files()
+        with warnings.catch_warnings():
+            warnings.filterwarnings("ignore", "setup.py install is deprecated")
+            obj = d.get_command_obj("install", create=True)
+        assert obj is not None
+        obj.finalize_options()
+
+        paths = sysconfig.get_paths().copy()
+        for key in SCHEME_KEYS:
+            if key == "headers":
+                # headers is not a path returned by sysconfig.get_paths()
+                continue
+
+            paths[key] = getattr(obj, f"install_{key}")
+
+        if site.check_enableusersite():
+            usersite = getattr(obj, "install_usersite", None)
+            userbase = getattr(obj, "install_userbase", None)
+            if usersite is not None and userbase is not None:
+                paths["usersite"] = usersite
+                paths["userbase"] = userbase
+
+        return paths
+
+    def get_supported_tags(self) -> list[Tag]:
+        return list(sys_tags())
+
+    def get_marker_env(self) -> dict[str, Any]:
+        if hasattr(sys, "implementation"):
+            info = sys.implementation.version
+            iver = f"{info.major}.{info.minor}.{info.micro}"
+            kind = info.releaselevel
+            if kind != "final":
+                iver += kind[0] + str(info.serial)
+
+            implementation_name = sys.implementation.name
+        else:
+            iver = "0"
+            implementation_name = ""
+
+        return {
+            "implementation_name": implementation_name,
+            "implementation_version": iver,
+            "os_name": os.name,
+            "platform_machine": platform.machine(),
+            "platform_release": platform.release(),
+            "platform_system": platform.system(),
+            "platform_version": platform.version(),
+            "python_full_version": platform.python_version(),
+            "platform_python_implementation": platform.python_implementation(),
+            "python_version": ".".join(platform.python_version().split(".")[:2]),
+            "sys_platform": sys.platform,
+            "version_info": sys.version_info,
+            "interpreter_name": interpreter_name(),
+            "interpreter_version": interpreter_version(),
+        }
+
+    def get_pip_version(self) -> Version:
+        from pip import __version__
+
+        return Version.parse(__version__)
 
     def _run(self, cmd: list[str], **kwargs: Any) -> int | str:
         self.executed.append(cmd)
@@ -2009,3 +1997,57 @@ class MockEnv(NullEnv):
 
     def is_venv(self) -> bool:
         return self._is_venv
+
+
+class InterpreterLookup:
+    @staticmethod
+    def _version_check(executable, supported_python=None):
+        try:
+            python_patch = decode(
+                subprocess.check_output(
+                    list_to_shell_command(
+                        [executable, "-c", GET_PYTHON_VERSION_ONELINER]
+                    ),
+                    shell=True
+                )
+            )
+        except CalledProcessError:
+            return False, None, None
+
+        if not python_patch:
+            return False, None, None
+
+        if (
+            not supported_python or
+            (supported_python and supported_python.allows(Version.parse(python_patch)))
+        ):
+            python_minor = ".".join(python_patch.split(".")[:2])
+            return True, python_minor, python_patch
+
+        return False, None, None
+
+    @classmethod
+    def find(cls, constraint=None):
+        executable, minor, patch = None, None, None
+
+        for guess in ["python", "python3", "python2"]:
+            match, minor, patch = cls._version_check(guess, constraint)
+            if match:
+                return guess, minor, patch
+
+        for python_to_try in sorted(
+            Package.AVAILABLE_PYTHONS,
+            key=lambda v: (
+                v.startswith("3"),
+                len(v) == 1,
+                int(v.split(".")[0]) * 100 + int((v.split(".") + ["0"])[1])
+            ),
+            reverse=True
+        ):
+            guess = f"python{python_to_try}"
+            match, minor, patch = cls._version_check(guess, constraint)
+            if match:
+                executable = guess
+                break
+
+        return executable, minor, patch
diff --git a/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.sha256sum b/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.sha256sum
deleted file mode 100644
index 3229630a..00000000
--- a/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.sha256sum
+++ /dev/null
@@ -1 +0,0 @@
-be3d3b916cb47038899d6ff37e875fd08ba3fed22bcdbf5a92f3f48fd2f15da8
diff --git a/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.tar.gz b/tests/console/commands/self/fixtures/poetry-1.0.5-darwin.tar.gz
deleted file mode 100644
index 09bb17bdeb92ccdc331cba93b1337ec9129f355f..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1041
zcmV+s1n&DEiwFP)U%p-h1MOJdi`zyJ_p|<r#d(pzRU})o!Ehxdy+R?}8TXo(QWiy8
zrJKlFb$5N#l>YCX*_Cv%F2aS{p-ERS`!V0Y+0l+v3#R4q<>Z=A2+w-Go|ti!m@!<$
zcErsvoJ7l2vW}DW66RsFSR|_nNv`QstNWmIDhZh=_AXVLv#KQwMqn$7!QNM}tZn}7
z5Y)$OgoFuR#WvsT=lNeo(Hir=SS5>iu?D^<j*@6X!fQA))cHTpe<8)5P+A=HK{84S
z-`7HFlD<=-JZMJk+8bdzR6G+oqb1i&rls;MV?gO6lZuP#Nn>xTVah~R@b`foTEnl+
zX2VgZ*~j!fQ!Vk0$UZVTLflI6fn|DYWf~^QYN5Cmk~0<5LX@qlEzBF9gXX0QXeRb`
zsylkBe><UTu`g-COV)Bcz{U@-_B<~uQ>Dn(l+woY2t03ZcR&4je@AWr+zty%%2@%M
zyyBWt-!P+qVr4P!R%mEW$P1#6HQSIadV^f}lp;$@a2L_*@#H+y9Z!Q?k34|Ksxry|
z(jH%faZ7(@rb!UeXPeF*dLLMLZb*xak5SA9JdI}nOfwtM`_TbYfBBpfT(>-UELxYX
zFV=CO+R1=wj=~M3OqBl2rsY*FMa`r>8dgjay6>a5UZ9dep;RVYHr_GeCb~xcDV6?=
zeDf_C$;OHH79Zo!bMN}dj95825+}O*!ebEt55PL2`i(8c7W1KU%*Tk|2>pmsQ<R@n
zi9%xvZGuNs_KqtmKJl|T8C|{=)3g`#91kA^GTZdBXXCaxH1%$zQMEmGR^;hWcI2LA
z8wj2-wAkS>CpbN^hJcLQLUyo(gH<_*@YGHZrg>8oC$=n7<JPSFQ$c+)vf=IO*8gz?
zn*Oi7kFL@Ip6UO>WEl<nzvXJ_`oGU{beeuoD6g5R<3H@;@TFLZ-&5#+=<fdh0p1J(
zdMxNvf}G1L-7~*kOO}>M@S)L!JC)Me%%g8_@4mm^^`t%sUin7VoJ^r<s&XNx!1(&-
z-R}18VMM^Zh8h~k)yF^ong)fC`&9eWU>X>$N=yH7Mqryf5)Rk*Q3Y*R#;Zd7vRV8J
zK0zn&f_#_f#2RNg$yp74uquQ8k!S%u3xwyPxS8=vLC4^Sb29L9=6#OjUBE_H|1BK!
z@~?n%^&c))gZfXRFn0BSf%KkL(fc}qQk+IX7$nm#<?x=3&M}-rpsW9V%HeDM^2HAh
zoU8w684v0|UdHbJKbN|T(EGQ($MMGm-rVrp<_6vdl-g4<wIBNCClLOxfqz5YZxH0L
z9~yWovOl=?am$D6^db&AB@O|HfJ49`;1F;KI0PI54grUNL%<>65O4@M1RMhY3W2`?
LE~wAj04M+eXZ{jT

diff --git a/tests/console/commands/self/test_update.py b/tests/console/commands/self/test_update.py
deleted file mode 100644
index 1c20920d..00000000
--- a/tests/console/commands/self/test_update.py
+++ /dev/null
@@ -1,66 +0,0 @@
-from __future__ import annotations
-
-from pathlib import Path
-from typing import TYPE_CHECKING
-
-import pytest
-
-from poetry.core.packages.package import Package
-from poetry.core.semver.version import Version
-
-from poetry.__version__ import __version__
-from poetry.factory import Factory
-
-
-if TYPE_CHECKING:
-    from cleo.testers.command_tester import CommandTester
-
-    from tests.helpers import TestRepository
-    from tests.types import CommandTesterFactory
-
-FIXTURES = Path(__file__).parent.joinpath("fixtures")
-
-
-@pytest.fixture()
-def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
-    return command_tester_factory("self update")
-
-
-def test_self_update_can_update_from_recommended_installation(
-    tester: CommandTester,
-    repo: TestRepository,
-    installed: TestRepository,
-):
-    new_version = Version.parse(__version__).next_minor().text
-
-    old_poetry = Package("poetry", __version__)
-    old_poetry.add_dependency(Factory.create_dependency("cleo", "^0.8.2"))
-
-    new_poetry = Package("poetry", new_version)
-    new_poetry.add_dependency(Factory.create_dependency("cleo", "^1.0.0"))
-
-    installed.add_package(old_poetry)
-    installed.add_package(Package("cleo", "0.8.2"))
-
-    repo.add_package(new_poetry)
-    repo.add_package(Package("cleo", "1.0.0"))
-
-    tester.execute()
-
-    expected_output = f"""\
-Updating Poetry version ...
-
-Using version ^{new_version} for poetry
-
-Updating dependencies
-Resolving dependencies...
-
-Writing lock file
-
-Package operations: 0 installs, 2 updates, 0 removals
-
-  • Updating cleo (0.8.2 -> 1.0.0)
-  • Updating poetry ({__version__} -> {new_version})
-"""
-
-    assert tester.io.fetch_output() == expected_output
diff --git a/tests/repositories/test_installed_repository.py b/tests/repositories/test_installed_repository.py
index 87dfe183..904a11cf 100644
--- a/tests/repositories/test_installed_repository.py
+++ b/tests/repositories/test_installed_repository.py
@@ -80,11 +80,6 @@ def mock_git_info(mocker: MockerFixture) -> None:
     )
 
 
-@pytest.fixture(autouse=True)
-def mock_installed_repository_vendors(mocker: MockerFixture) -> None:
-    mocker.patch("poetry.repositories.installed_repository._VENDORS", str(VENDOR_DIR))
-
-
 @pytest.fixture
 def repository(mocker: MockerFixture, env: MockEnv) -> InstalledRepository:
     mocker.patch(
@@ -104,7 +99,7 @@ def get_package_from_repository(
 
 
 def test_load_successful(repository: InstalledRepository):
-    assert len(repository.packages) == len(INSTALLED_RESULTS) - 1
+    assert len(repository.packages) == len(INSTALLED_RESULTS)
 
 
 def test_load_successful_with_invalid_distribution(
@@ -119,7 +114,7 @@ def test_load_successful_with_invalid_distribution(
     repository_with_invalid_distribution = InstalledRepository.load(env)
 
     assert (
-        len(repository_with_invalid_distribution.packages) == len(INSTALLED_RESULTS) - 1
+        len(repository_with_invalid_distribution.packages) == len(INSTALLED_RESULTS)
     )
     assert len(caplog.messages) == 1
 
@@ -128,11 +123,6 @@ def test_load_successful_with_invalid_distribution(
     assert str(invalid_dist_info) in message
 
 
-def test_load_ensure_isolation(repository: InstalledRepository):
-    package = get_package_from_repository("attrs", repository)
-    assert package is None
-
-
 def test_load_standard_package(repository: InstalledRepository):
     cleo = get_package_from_repository("cleo", repository)
     assert cleo is not None
diff --git a/tests/utils/test_env.py b/tests/utils/test_env.py
index 32fb5cb0..2c7f58b1 100644
--- a/tests/utils/test_env.py
+++ b/tests/utils/test_env.py
@@ -220,7 +220,7 @@ def test_activate_activates_non_existing_virtualenv_no_envs_file(
     )
     mocker.patch(
         "subprocess.Popen.communicate",
-        side_effect=[("/prefix", None), ("/prefix", None)],
+        side_effect=[("/prefix", None), ("/prefix", None), ("/prefix", None)],
     )
     m = mocker.patch("poetry.utils.env.EnvManager.build_venv", side_effect=build_venv)
 
@@ -522,7 +522,7 @@ def test_deactivate_non_activated_but_existing(
 
     mocker.patch(
         "subprocess.check_output",
-        side_effect=check_output_wrapper(),
+        side_effect=check_output_wrapper(Version.parse("3.10.5")),
     )
 
     manager.deactivate(NullIO())
@@ -562,7 +562,7 @@ def test_deactivate_activated(
 
     mocker.patch(
         "subprocess.check_output",
-        side_effect=check_output_wrapper(),
+        side_effect=check_output_wrapper(Version.parse("3.10.5")),
     )
 
     manager.deactivate(NullIO())
@@ -858,7 +858,7 @@ def test_create_venv_tries_to_find_a_compatible_python_executable_using_generic_
     mocker.patch("sys.version_info", (2, 7, 16))
     mocker.patch(
         "subprocess.check_output",
-        side_effect=check_output_wrapper(Version.parse("3.7.5")),
+        side_effect=["3.7.5", "3.7.5", "2.7.16", "3.7.5"],
     )
     m = mocker.patch(
         "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
@@ -893,7 +893,15 @@ def test_create_venv_tries_to_find_a_compatible_python_executable_using_specific
     venv_name = manager.generate_env_name("simple-project", str(poetry.file.parent))
 
     mocker.patch("sys.version_info", (2, 7, 16))
-    mocker.patch("subprocess.check_output", side_effect=["3.5.3", "3.9.0"])
+    mocker.patch("subprocess.check_output", side_effect=[
+        "3.5.3",
+        "3.10.0",
+        "3.5.3",
+        "3.5.3",
+        "2.7.16",
+        "3.5.3",
+        "3.10.0"
+    ])
     m = mocker.patch(
         "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
     )
@@ -901,15 +909,15 @@ def test_create_venv_tries_to_find_a_compatible_python_executable_using_specific
     manager.create_venv(NullIO())
 
     m.assert_called_with(
-        config_virtualenvs_path / f"{venv_name}-py3.9",
-        executable="python3.9",
+        config_virtualenvs_path / f"{venv_name}-py3.10",
+        executable="python3.10",
         flags={
             "always-copy": False,
             "system-site-packages": False,
             "no-pip": False,
             "no-setuptools": False,
         },
-        prompt="simple-project-py3.9",
+        prompt="simple-project-py3.10",
     )
 
 
@@ -921,7 +929,7 @@ def test_create_venv_fails_if_no_compatible_python_version_could_be_found(
 
     poetry.package.python_versions = "^4.8"
 
-    mocker.patch("subprocess.check_output", side_effect=["", "", "", ""])
+    mocker.patch("subprocess.check_output", side_effect=lambda *args, **kwargs: "")
     m = mocker.patch(
         "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
     )
@@ -947,7 +955,7 @@ def test_create_venv_does_not_try_to_find_compatible_versions_with_executable(
 
     poetry.package.python_versions = "^4.8"
 
-    mocker.patch("subprocess.check_output", side_effect=["3.8.0"])
+    mocker.patch("subprocess.check_output", side_effect=["3.8.0" for _ in range(1 + 12)])
     m = mocker.patch(
         "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
     )
@@ -981,10 +989,9 @@ def test_create_venv_uses_patch_version_to_detect_compatibility(
     )
     venv_name = manager.generate_env_name("simple-project", str(poetry.file.parent))
 
-    mocker.patch("sys.version_info", (version.major, version.minor, version.patch + 1))
     check_output = mocker.patch(
         "subprocess.check_output",
-        side_effect=check_output_wrapper(Version.parse("3.6.9")),
+        side_effect=["2.7.16" for _ in range(3)] + [f"{version.major}.{version.minor}.{version.patch + 1}"],
     )
     m = mocker.patch(
         "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
@@ -992,10 +999,9 @@ def test_create_venv_uses_patch_version_to_detect_compatibility(
 
     manager.create_venv(NullIO())
 
-    assert not check_output.called
     m.assert_called_with(
         config_virtualenvs_path / f"{venv_name}-py{version.major}.{version.minor}",
-        executable=None,
+        executable="python3",
         flags={
             "always-copy": False,
             "system-site-packages": False,
@@ -1100,7 +1106,7 @@ def test_activate_with_in_project_setting_does_not_fail_if_no_venvs_dir(
     )
     mocker.patch(
         "subprocess.Popen.communicate",
-        side_effect=[("/prefix", None), ("/prefix", None)],
+        side_effect=[("/prefix", None), ("/prefix", None), ("/prefix", None)],
     )
     m = mocker.patch("poetry.utils.env.EnvManager.build_venv")
 
@@ -1123,7 +1129,7 @@ def test_activate_with_in_project_setting_does_not_fail_if_no_venvs_dir(
 
 
 def test_system_env_has_correct_paths():
-    env = SystemEnv(Path(sys.prefix))
+    env = SystemEnv(Path(sys.prefix), auto_path=False)
 
     paths = env.paths
 
@@ -1133,18 +1139,6 @@ def test_system_env_has_correct_paths():
     assert env.site_packages.path == Path(paths["purelib"])
 
 
-@pytest.mark.parametrize(
-    "enabled",
-    [True, False],
-)
-def test_system_env_usersite(mocker: MockerFixture, enabled: bool):
-    mocker.patch("site.check_enableusersite", return_value=enabled)
-    env = SystemEnv(Path(sys.prefix))
-    assert (enabled and env.usersite is not None) or (
-        not enabled and env.usersite is None
-    )
-
-
 def test_venv_has_correct_paths(tmp_venv: VirtualEnv):
     paths = tmp_venv.paths
 
@@ -1392,7 +1386,7 @@ def test_build_environment_called_build_script_specified(
         assert env == ephemeral_env
         assert env.executed == [
             [
-                "python",
+                env.python,
                 env.pip_embedded,
                 "install",
                 "--disable-pip-version-check",
@@ -1446,7 +1440,7 @@ def test_create_venv_project_name_empty_sets_correct_prompt(
 
     m.assert_called_with(
         config_virtualenvs_path / f"{venv_name}-py3.7",
-        executable="python3",
+        executable="python",
         flags={
             "always-copy": False,
             "system-site-packages": False,
